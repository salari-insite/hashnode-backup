---
title: "An Honest Review of GitHub Copilot"
slug: an-honest-review-of-github-copilot
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/UT8LMo-wlyk/upload/6585adde93b70e5db702a81ce15e6e1b.jpeg

---

# Introduction

In case you're not familiar, GitHub Copilot is GitHub's "AI pair programmer" that provides intelligent code completion and a chatbot capable of answering any programming-related questions.

The concept behind GitHub Copilot is to enable developers to generate code more quickly, primarily by minimizing the amount of typing needed for boilerplate code and saving time when searching for answers to questions. Instead of using Google to find a solution, you can simply enter your question into the chatbot integrated with your IDE and receive a detailed, customized answer for your program in seconds.

In this review, I will provide my honest feedback on my experience using GitHub Copilot in various contexts, such as learning a new programming language, learning and practicing machine learning in Python, and developing a personal project. I will discuss some of the standout features that I use, identify areas where I believe improvements could be made, and share my overall evaluation of Copilot.

To preface, although this is not a sponsored post, I am able to use Copilot for free as a university student. My access to GitHub's student developer pack, which includes a free Copilot subscription, is granted due to my student status. As a result, my review may be somewhat biased, as the average person would need to pay for a subscription.

In addition to the point above, as a student, my experience with Copilot may be biased because I lack professional experience as a software engineer. Consequently, I cannot attest to how Copilot would perform in a "real-world" setting.

My goal in this review is to offer insights into how Copilot functions, as well as its features and drawbacks, before someone decides to purchase a subscription for its use.

---

## The Pros: Unveiling the Strengths

### Efficiency and productivity

### Accuracy and usefulness

### Time savings

---

## The Cons: Addressing the Limitations

### Ambiguous/incorrect code suggestions

### Learning curve

### Code quality

---

## Conclusion