---
title: "Comparing Data Structures: Lists vs Linked Lists"
slug: comparing-data-structures-lists-vs-linked-lists
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/BW0vK-FA3eg/upload/908ca908b79a4463343f88adf6155d3e.jpeg
tags: 2articles1week

---

# Introduction

---

## I. Lists

Lists consist of ordered, mutable elements. They enable simple insertion, deletion, and traversal of elements while offering dynamic resizing capabilities.

With lists, all elements are stored contiguously in memory. This characteristic enables lists to quickly return elements at a specified index.

In many programming languages, lists are a built-in data structure. This means that you don't have to manually create lists and their associated methods.

### a) Creating a list in Python

```python
# Creating an empty list
new_list = []

# Creating list with values
names = ['Jack', 'Jill', 'Jane', 'Jeff']

# Creating list with 'list' function
# (Python requires iterable argument)
digits_set = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
digits_list = list(digits)
```

In the final example of creating a list in Python, we needed to provide an iterable data type, such as a tuple, string, set, or dictionary.

Python converts the iterable data type into a list.

For tuples and sets, this simply means that Python converts all the elements directly into a list while maintaining the same order.

For strings, Python slices the string into individual characters and creates a list element for each character in the string.

For dictionaries, Python creates a list element for each key in the dictionary.

### b) List methods

* append(*el*) - adds *el* to the end of the list
    
* insert(*index*, *el*) - adds *el* to specified *index* (shifts the elements to the right by 1 index)
    
* remove(*el*) - removes first instance of *el* in the list
    
* pop() - removes last element of the list, and returns the element it removed
    
* clear() - deletes all the elements from the list
    
* index(*index*) - returns element at specified *index* (this can also be done with square bracket syntax: `l[index]`)
    
* count(*val*) - returns number of elements that contain the value *val*
    
* sort() - sorts the list from least to greatest (or alphabetically for a list of strings)
    
* reverse() - sorts the list from greatest to least (or reverse alphabetically for a list of strings)
    

### c) Advantages

The primary advantage of lists lies in their simplicity and the fact that they come pre-built in most programming languages.

Secondly, lists provide quick access to elements at a specified index, as they are stored contiguously in memory.

This means that the time complexity of indexing an element in a list is constant:

$$O(1)$$

### d) Disadvantages

The primary drawback of lists is that they are somewhat slow when it comes to removing and inserting elements at specific indices.

This is due to the necessity of shifting all elements to maintain contiguity in memory, which results in slower insertion and removal of elements at specific indices.

This means that the time complexity for removing and inserting elements in a list is linear:

$$O(n)$$

## II. Linked lists

Linked lists are a data structure composed of nodes, with each node containing an element and a reference to the subsequent node in the sequence. This enables efficient insertion and deletion of elements at any position but demands more memory and offers slower element access compared to lists.

Unlike lists, linked lists are not built-in data structures, which means you will need to manually code and create linked lists along with their associated methods.

### a) Creating a linked list

```python
# Class to construct new nodes
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

# Class to construct new linked lists
class LinkedList:
    def __init__(self):
        self.head = None
    
    # Method to add new nodes to linked list
    def append(self, data):
        # If linked list is empty
        if self.head is None:
            self.head = Node(data)
            return

        last_node = self.head
        while last_node.next is not None:
            last_node = last_node.next
        last_node.next = Node(data)

# Example usage:
linked_list = LinkedList()
linked_list.append(1)
linked_list.append(2)
linked_list.append(3)
```

### b) Linked list methods

### c) Advantages

### d) Disadvantages

## III. Conclusion

---

![a person typing on a laptop on a desk](https://cdn.hashnode.com/res/hashnode/image/upload/v1694158493008/jsZzIo77t.jpg?w=800&auto=compress&auto=compress,format&format=webp&auto=compress,format&format=webp&auto=compress,format&format=webp&auto=compress,format&format=webp&auto=compress,format&format=webp align="center")

This article is part of a series called [**Bit by Bit**](https://scrappedscript.com/series/bit-by-bit), a series devoted to all things programming. Whether you're still a computer science undergrad or the CTO of Apple, there's something for you here.

New articles in this series are posted every Tuesday!